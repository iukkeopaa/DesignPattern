### 门面模式

提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用

### 优点

* 简化接口：外观模式通过提供一个统一的接口，隐藏了子系统的复杂性，让客户端能够更简单、方便地使用子系统功能。客户端只需与外观类交互，无需了解子系统内部的具体实现和各个组件之间的复杂交互。比如在一个电商系统中，包含库存管理、订单处理、支付等多个子系统。使用外观模式可以创建一个统一的订单服务外观类，客户端只需调用这个外观类的下单方法，而不用去和库存管理、订单处理、支付等子系统分别交互，降低了客户端使用的难度。
* 解耦客户端和子系统：外观模式将客户端与子系统的实现细节隔离开来，使得客户端和子系统之间的依赖关系更加松散。子系统的内部实现发生变化时，只要外观类的接口不变，客户端就不需要做任何修改。例如，当电商系统的支付子系统更换支付方式或调整支付流程时，只要订单服务外观类的下单方法接口不变，客户端代码就无需改动。
* 提高可维护性：由于外观模式封装了子系统的复杂性，使得系统的结构更加清晰，维护起来更加容易。当需要对某个子系统进行修改或扩展时，只需要在外观类中进行相应的调整，而不会影响到客户端。例如，若要在电商系统中新增一种支付方式，只需在订单服务外观类中对支付相关的逻辑进行修改，而不会影响到客户端调用下单方法的代码。
* 遵循迪米特法则：也称为最少知识原则，即一个对象应该对其他对象有最少的了解。外观模式让客户端只与外观类交互，减少了客户端与子系统中多个模块的直接联系，降低了系统的耦合度。

### 缺点

* 不符合开闭原则：在系统中添加新的子系统功能时，可能需要修改外观类，这违背了开闭原则（对扩展开放，对修改关闭）。例如，若电商系统要新增一个物流跟踪子系统，可能需要在订单服务外观类中添加相应的逻辑，这就需要修改现有的外观类代码。
* 外观类可能过于庞大：随着子系统功能的不断增加，外观类可能会变得越来越复杂，包含大量的业务逻辑和方法调用，导致外观类本身难以维护和扩展。比如，当电商系统不断增加新的功能模块，如营销活动、客户评价等，订单服务外观类可能会变得臃肿，难以管理。
* 限制灵活性：外观模式提供了一个统一的高层接口，这在一定程度上限制了客户端对子系统的个性化使用。如果客户端需要使用子系统的一些特殊功能，而外观类没有提供相应的接口，那么客户端就需要绕过外观类直接与子系统交互，这样就破坏了外观模式的封装性。